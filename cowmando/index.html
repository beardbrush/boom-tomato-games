<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Red Baron vs Cowmandos</title>
<style>
  html,body{
    margin:0;
    height:100%;
    overflow:hidden;
    background:#5bd3ff;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    color:#fff;
  }
  canvas{ display:block; }
  .hud{
    position:fixed; top:8px; left:8px;
    padding:6px 10px;
    background:rgba(0,0,0,.45);
    border-radius:8px;
    font-size:14px;
    pointer-events:none;
  }
  .center-msg{
    position:fixed; inset:0;
    display:flex; align-items:center; justify-content:center;
    font-size:22px; text-align:center; pointer-events:none;
    white-space:pre-line;
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div class="hud" id="hud"></div>
<div class="center-msg" id="centerMsg"></div>

<script>
(function(){
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; }
addEventListener("resize", resize); resize();

// ---- SPRITES ----
const planeImg  = new Image(); planeImg.src  = "RedBarontriplane-Sheet.gif";
const blueBombImg  = new Image(); blueBombImg.src  = "BlueBombBetterSpinv4-Sheet.gif";
const greenBombImg = new Image(); greenBombImg.src = "GreenBombBetterSpinv4-Sheet.gif";
const cowImg   = new Image(); cowImg.src   = "CowMando.png";

const assets = [planeImg, blueBombImg, greenBombImg, cowImg];
let loaded = 0;
assets.forEach(i => i.onload = () => { if(++loaded === assets.length) start(); });

// ---- SOUND SYSTEM ----
const snd = {
  engine: new Audio("sounds/plane_engine_loop.wav"),
  moo: new Audio("sounds/moo.wav"),
  explosion: new Audio("sounds/explosion.wav")
};
snd.engine.loop = true;
snd.engine.volume = 0.35;
let engineStarted = false;

function playSound(audio){
  const a = audio.cloneNode();
  a.volume = audio.volume ?? 1;
  a.play().catch(()=>{});
}

// ---- SPRITE META ----
const sprites = {
  plane:{
    img:planeImg, frames:4,
    get fw(){ return this.img.width/4; },
    get fh(){ return this.img.height; },
    scale:0.13  // small plane
  },
  cow:{
    img:cowImg, frames:4,
    get fw(){ return this.img.width/4; },
    get fh(){ return this.img.height; },
    scale:1.35  // bigger cows
  },
  bossCow:{
    img:cowImg, frames:4,
    get fw(){ return this.img.width/4; },
    get fh(){ return this.img.height; },
    scale:2.2   // big boss
  },
  blueBomb:{
    img:blueBombImg, frames:2,
    get fw(){ return this.img.width/2; },
    get fh(){ return this.img.height; },
    scale:0.65
  },
  greenRocket:{
    img:greenBombImg, frames:2,
    get fw(){ return this.img.width/2; },
    get fh(){ return this.img.height; },
    scale:0.70
  }
};

// ---- INPUT ----
const keys = {};
let mouseDown = false;

addEventListener("keydown", e=>{
  keys[e.key.toLowerCase()] = 1;

  // Start engine on first user input (autoplay rules)
  if(!engineStarted && !gameOver){
    snd.engine.currentTime = 0;
    snd.engine.play().catch(()=>{});
    engineStarted = true;
  }

  if(e.key === " "){
    e.preventDefault();
    if(gameOver) reset();
  }
});
addEventListener("keyup", e=>{ keys[e.key.toLowerCase()] = 0; });

canvas.addEventListener("pointerdown", e=>{
  mouseDown = true;
});
canvas.addEventListener("pointerup", e=>{
  mouseDown = false;
});
canvas.addEventListener("pointerleave", e=>{
  mouseDown = false;
});

// ---- GAME STATE ----
let last = 0;
let gameOver = false;
let score = 0;
let lives = 3;

const plane = {
  x:0,y:0,vx:0,vy:0,
  speed:300,
  facing:1,           // 1 = right, -1 = left
  frame:0, ft:0,
  bombCD:0.22, bt:0,
  gunCD:0.10, gunTimer:0
};

const cows = [];
const bombs = [];
const rockets = [];
const bullets = [];
const explosions = [];

let cowTimer = 1;
let cowRate = 2.4;

// boss cow
let boss = null;
let bossAppeared = false;

// clouds for parallax
const clouds = [];
function makeCloud(){
  return {
    x:Math.random()*canvas.width,
    y:Math.random()*canvas.height*0.6,
    w:80+Math.random()*140,
    h:30+Math.random()*35,
    speed:20+Math.random()*25,
    depth:Math.random()<0.5?0.5:1
  };
}
for(let i=0;i<10;i++) clouds.push(makeCloud());

function start(){
  reset();
  requestAnimationFrame(loop);
}

function reset(){
  gameOver = false;
  score = 0;
  lives = 3;
  cows.length = bombs.length = rockets.length = bullets.length = explosions.length = 0;
  cowTimer = 1;
  cowRate = 2.4;
  boss = null;
  bossAppeared = false;

  const p = sprites.plane;
  const w = p.fw*p.scale;
  const h = p.fh*p.scale;
  plane.x = canvas.width*0.2 - w/2;
  plane.y = canvas.height*0.35 - h/2;
  plane.bt = 0;
  plane.gunTimer = 0;
  plane.facing = 1;

  snd.engine.pause();
  snd.engine.currentTime = 0;
  engineStarted = false;

  document.getElementById("centerMsg").textContent =
    "WASD / Arrows = fly\nSPACE = drop blue bombs\nJ / F / K or TAP = machine gun (white shots forward)";
}

function spawnCow(){
  const c = sprites.cow;
  const w = c.fw*c.scale;
  const h = c.fh*c.scale;

  const fromLeft = Math.random() < 0.5;
  const dir = fromLeft ? 1 : -1;
  const x = fromLeft ? -w : canvas.width + w;
  const y = canvas.height - h - 14;

  cows.push({
    x,
    y,
    dir,                 // -1 = left, 1 = right
    speed: 55 + Math.random()*45,
    ft:0, frame:0,
    shoot:1 + Math.random()*1.4,
    hp:1,
    upgraded:false
  });
}

function spawnBossCow(){
  const s = sprites.bossCow;
  const w = s.fw*s.scale;
  const h = s.fh*s.scale;
  boss = {
    x:canvas.width + w,
    y:canvas.height - h - 30,
    dir:-1,
    speed:25,
    ft:0, frame:0,
    fire:0.8,
    hp:10,
    upgraded:false
  };
  playSound(snd.moo);
}

function addExplosion(x,y,scale=1){
  explosions.push({
    x,y,
    t:0,
    ttl:0.55,
    maxR:40*scale
  });
}

function dropBomb(){
  const p = sprites.plane;
  const w = p.fw*p.scale;
  const h = p.fh*p.scale;
  const b = sprites.blueBomb;
  const bw = b.fw*b.scale;

  const front = (plane.facing===1?0.7:0.3);
  bombs.push({
    x:plane.x + w*front - bw/2,
    y:plane.y + h*0.3,
    vy:240,
    ft:0, f:0
  });
}

function fireBullet(){
  const p = sprites.plane;
  const w = p.fw*p.scale;
  const h = p.fh*p.scale;

  // nose position based on facing
  const noseX = plane.facing === 1
    ? plane.x + w * 0.9   // near right end
    : plane.x + w * 0.1;  // near left end

  const noseY = plane.y + h * 0.45; // roughly middle vertically

  bullets.push({
    x: noseX,
    y: noseY,
    vx: plane.facing * 550, // forward along facing
    radius: 4
  });
}

function fireRocketFrom(x,y){
  rockets.push({
    x,
    y,
    vy:-260,
    ft:0, f:0
  });
}

// ---- UPDATE ----
function update(dt){
  if(gameOver) return;

  // boss spawn when enough score
  if(!bossAppeared && score >= 800){
    bossAppeared = true;
    spawnBossCow();
  }

  // plane movement
  plane.vx = (keys["a"]||keys["arrowleft"]?-plane.speed:0) +
             (keys["d"]||keys["arrowright"]? plane.speed:0);
  plane.vy = (keys["w"]||keys["arrowup"]?-plane.speed:0) +
             (keys["s"]||keys["arrowdown"]? plane.speed:0);

  if(plane.vx < -10) plane.facing = -1;
  else if(plane.vx > 10) plane.facing = 1;

  plane.x += plane.vx*dt;
  plane.y += plane.vy*dt;

  const p = sprites.plane;
  const pw = p.fw*p.scale;
  const ph = p.fh*p.scale;
  plane.x = Math.max(0, Math.min(canvas.width-pw, plane.x));
  plane.y = Math.max(0, Math.min(canvas.height-ph*0.9, plane.y));

  // engine volume based on speed
  if(engineStarted){
    const speedMag = Math.abs(plane.vx) + Math.abs(plane.vy);
    snd.engine.volume = 0.2 + Math.min(speedMag/900, 0.4);
  }

  plane.ft += dt;
  if(plane.ft > 0.10){
    plane.ft = 0;
    plane.frame = (plane.frame+1)%p.frames;
  }

  // bombs (SPACE)
  plane.bt -= dt;
  if((keys[" "] || keys["space"]) && plane.bt <= 0){
    dropBomb();
    plane.bt = plane.bombCD;
  }

  // gun (J/F/K or tap)
  plane.gunTimer -= dt;
  const gunPressed = keys["j"] || keys["f"] || keys["k"] || mouseDown;
  if(gunPressed && plane.gunTimer <= 0){
    fireBullet();
    plane.gunTimer = plane.gunCD;
  }

  // bombs update
  for(let i=bombs.length-1;i>=0;i--){
    const b = bombs[i];
    b.y += b.vy*dt;
    b.ft += dt;
    if(b.ft>0.08){ b.ft=0; b.f=(b.f+1)%sprites.blueBomb.frames; }
    if(b.y > canvas.height+50) bombs.splice(i,1);
  }

  // bullets update (forward)
  for(let i=bullets.length-1;i>=0;i--){
    const bl = bullets[i];
    bl.x += bl.vx*dt;
    if(bl.x < -40 || bl.x > canvas.width+40) bullets.splice(i,1);
  }

  // cows
  cowTimer -= dt;
  if(cowTimer<=0){
    spawnCow();
    cowRate = Math.max(1.1, cowRate*0.97);
    cowTimer = cowRate;
  }

  for(let i=cows.length-1;i>=0;i--){
    const c = cows[i];
    const cw = sprites.cow.fw*sprites.cow.scale;

    c.x += c.speed * dt * c.dir;

    c.ft += dt;
    if(c.ft>0.13){ c.ft=0; c.frame=(c.frame+1)%sprites.cow.frames; }

    c.shoot -= dt;
    if(c.shoot<=0){
      const frontX = c.dir < 0 ? c.x + cw*0.25 : c.x + cw*0.75;
      fireRocketFrom(frontX, c.y);
      c.shoot = 1 + Math.random()*1.3;
    }

    // crossing: upgrade once to 2-hit cow
    if(c.dir < 0 && c.x < -cw){
      if(!c.upgraded){
        c.upgraded = true;
        c.hp = 2;
        c.speed *= 1.15;
        c.dir = 1;
        c.x = -cw + 10;
      }else{
        cows.splice(i,1);
      }
    }else if(c.dir > 0 && c.x > canvas.width + cw){
      if(!c.upgraded){
        c.upgraded = true;
        c.hp = 2;
        c.speed *= 1.15;
        c.dir = -1;
        c.x = canvas.width + cw - 10;
      }else{
        cows.splice(i,1);
      }
    }
  }

  // boss cow logic
  if(boss){
    const s = sprites.bossCow;
    const bw = s.fw*s.scale;
    const bh = s.fh*s.scale;

    boss.x += boss.speed * dt * boss.dir;
    boss.ft += dt;
    if(boss.ft>0.12){ boss.ft=0; boss.frame=(boss.frame+1)%s.frames; }

    boss.fire -= dt;
    if(boss.fire<=0){
      fireRocketFrom(boss.x + bw*0.25, boss.y + 10);
      fireRocketFrom(boss.x + bw*0.75, boss.y + 10);
      boss.fire = 0.7;
    }

    const bwCurrent = s.fw*s.scale;
    if(!boss.upgraded){
      if(boss.dir < 0 && boss.x < -bwCurrent){
        boss.upgraded = true;
        sprites.bossCow.scale *= 2;
        boss.hp *= 2;
        boss.dir = 1;
        boss.x = -bwCurrent + 10;
      }else if(boss.dir > 0 && boss.x > canvas.width + bwCurrent){
        boss.upgraded = true;
        sprites.bossCow.scale *= 2;
        boss.hp *= 2;
        boss.dir = -1;
        boss.x = canvas.width + bwCurrent - 10;
      }
    }else{
      if(boss.dir < 0 && boss.x < -bwCurrent){
        boss.dir = 1;
        boss.x = -bwCurrent + 10;
      }else if(boss.dir > 0 && boss.x > canvas.width + bwCurrent){
        boss.dir = -1;
        boss.x = canvas.width + bwCurrent - 10;
      }
    }
  }

  // rockets: straight up
  for(let i=rockets.length-1;i>=0;i--){
    const r = rockets[i];
    r.y += r.vy*dt;
    r.ft += dt;
    if(r.ft>0.08){ r.ft=0; r.f=(r.f+1)%sprites.greenRocket.frames; }
    if(r.y < -80) rockets.splice(i,1);
  }

  // ---- collisions: bombs vs cows/boss ----
  for(let i=bombs.length-1;i>=0;i--){
    const b = bombs[i];
    const bw = sprites.blueBomb.fw*sprites.blueBomb.scale;
    const bh = sprites.blueBomb.fh*sprites.blueBomb.scale;
    const bx = b.x, by = b.y;
    let hitSomething = false;

    // cows
    for(let j=cows.length-1;j>=0;j--){
      const c = cows[j];
      const cw = sprites.cow.fw*sprites.cow.scale;
      const ch = sprites.cow.fh*sprites.cow.scale;
      if(overlap(bx,by,bw,bh,c.x,c.y,cw,ch)){
        addExplosion(c.x+cw/2, c.y+ch/2, 0.9);
        playSound(snd.moo);
        playSound(snd.explosion);
        c.hp -= 2;
        if(c.hp <= 0){
          cows.splice(j,1);
          score += c.upgraded ? 250 : 150;
        }else{
          score += 80;
        }
        hitSomething = true;
        break;
      }
    }

    // boss
    if(!hitSomething && boss){
      const s = sprites.bossCow;
      const cw = s.fw*s.scale;
      const ch = s.fh*s.scale;
      if(overlap(bx,by,bw,bh,boss.x,boss.y,cw,ch)){
        addExplosion(boss.x+cw/2, boss.y+ch/2, 1.2);
        playSound(snd.moo);
        boss.hp -= 2;
        score += 100;
        hitSomething = true;
        if(boss.hp <= 0){
          addExplosion(boss.x+cw/2, boss.y+ch/2, 2.2);
          playSound(snd.explosion);
          score += 1200;
          boss = null;
        }
      }
    }

    if(hitSomething){
      bombs.splice(i,1);
    }
  }

  // ---- collisions: bullets vs cows/boss ----
  for(let i=bullets.length-1;i>=0;i--){
    const bl = bullets[i];
    const br = bl.radius;
    const bx = bl.x - br;
    const by = bl.y - br;
    const bw = br*2;
    const bh = br*2;
    let hitSomething = false;

    // cows
    for(let j=cows.length-1;j>=0;j--){
      const c = cows[j];
      const cw = sprites.cow.fw*sprites.cow.scale;
      const ch = sprites.cow.fh*sprites.cow.scale;
      if(overlap(bx,by,bw,bh,c.x,c.y,cw,ch)){
        addExplosion(bl.x, bl.y, 0.4);
        c.hp -= 1;
        score += 40;
        if(c.hp <= 0){
          playSound(snd.moo);
          playSound(snd.explosion);
          cows.splice(j,1);
          score += c.upgraded ? 200 : 120;
        }
        hitSomething = true;
        break;
      }
    }

    // boss
    if(!hitSomething && boss){
      const s = sprites.bossCow;
      const cw = s.fw*s.scale;
      const ch = s.fh*s.scale;
      if(overlap(bx,by,bw,bh,boss.x,boss.y,cw,ch)){
        addExplosion(bl.x, bl.y, 0.6);
        boss.hp -= 1;
        score += 60;
        hitSomething = true;
        if(boss.hp <= 0){
          addExplosion(boss.x+cw/2, boss.y+ch/2, 2.2);
          playSound(snd.explosion);
          score += 1300;
          boss = null;
        }
      }
    }

    if(hitSomething){
      bullets.splice(i,1);
    }
  }

  // ---- rockets vs plane ----
  for(let i=rockets.length-1;i>=0;i--){
    const r = rockets[i];
    const rw = sprites.greenRocket.fw*sprites.greenRocket.scale;
    const rh = sprites.greenRocket.fh*sprites.greenRocket.scale;
    const pRect = { x:plane.x, y:plane.y, w:pw*0.7, h:ph*0.5 };

    if(overlap(pRect.x,pRect.y,pRect.w,pRect.h,r.x-rw/2,r.y,rw,rh)){
      rockets.splice(i,1);
      addExplosion(plane.x+pw/2, plane.y+ph/2, 1.2);
      playSound(snd.explosion);
      lives--;
      if(lives<=0){
        gameOver = true;
        snd.engine.pause();
        engineStarted = false;
        document.getElementById("centerMsg").textContent =
          "YOU WERE MILKED BY THE COWMANDOS ðŸ’¥\nScore: "+score+"\nPress SPACE to play again";
      }
    }
  }

  // ---- explosions life ----
  for(let i=explosions.length-1;i>=0;i--){
    const e = explosions[i];
    e.t += dt;
    if(e.t > e.ttl) explosions.splice(i,1);
  }

  document.getElementById("hud").textContent = `Score: ${score}  Lives: ${lives}`;
  if(!gameOver) document.getElementById("centerMsg").textContent = "";
}

function overlap(ax,ay,aw,ah,bx,by,bw,bh){
  return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
}

// ---- DRAW HELPERS ----
function drawCloud(c){
  ctx.fillStyle = c.depth===1 ? "#9be9ff" : "#baf3ff";
  ctx.fillRect(c.x,c.y,c.w,c.h);
}

function drawSprite(sprite, frame, x, y, flipX=false, rotate180=false){
  const fw = sprite.fw;
  const fh = sprite.fh;
  const scale = sprite.scale;
  const dw = fw*scale;
  const dh = fh*scale;
  const sx = frame*fw;

  if(rotate180){
    ctx.save();
    ctx.translate(x+dw/2, y+dh/2);
    ctx.rotate(Math.PI);
    ctx.drawImage(sprite.img, sx, 0, fw, fh, -dw/2, -dh/2, dw, dh);
    ctx.restore();
  }else if(flipX){
    ctx.save();
    ctx.translate(x+dw, y);
    ctx.scale(-1,1);
    ctx.drawImage(sprite.img, sx, 0, fw, fh, 0, 0, dw, dh);
    ctx.restore();
  }else{
    ctx.drawImage(sprite.img, sx, 0, fw, fh, x, y, dw, dh);
  }
}

// ---- RENDER ----
function render(){
  ctx.fillStyle = "#5bd3ff";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  clouds.forEach(c=>{
    c.x -= c.speed*c.depth*0.016;
    if(c.x < -c.w){ Object.assign(c, makeCloud(), { x:canvas.width }); }
    drawCloud(c);
  });

  ctx.fillStyle = "#62d255";
  ctx.fillRect(0, canvas.height*0.88, canvas.width, canvas.height);

  // plane
  drawSprite(sprites.plane, plane.frame, plane.x, plane.y, plane.facing===-1, false);

  // cows â€” flip if dir > 0 (moving right) so they always face walking direction
  cows.forEach(c=>{
    const flip = c.dir > 0;   // sprite faces left by default
    drawSprite(sprites.cow, c.frame, c.x, c.y, flip, false);
  });

  // boss cow â€” also flip based on dir
  if(boss){
    const bossFlip = boss.dir > 0;
    drawSprite(sprites.bossCow, boss.frame, boss.x, boss.y, bossFlip, false);
  }

  bombs.forEach(b=> drawSprite(sprites.blueBomb, b.f, b.x, b.y));

  // rockets straight up (rotated 180)
  rockets.forEach(r=> drawSprite(sprites.greenRocket, r.f, r.x, r.y, false, true));

  // bullets (white dots forward)
  ctx.fillStyle = "#fffb";
  bullets.forEach(bl=>{
    ctx.beginPath();
    ctx.arc(bl.x, bl.y, bl.radius, 0, Math.PI*2);
    ctx.fill();
  });

  // explosions
  explosions.forEach(e=>{
    const t = e.t / e.ttl;
    const r = e.maxR * t;
    const alpha = 1 - t;
    ctx.save();
    ctx.globalAlpha = alpha;
    const grad = ctx.createRadialGradient(e.x,e.y,0,e.x,e.y,r);
    grad.addColorStop(0,"rgba(255,255,255,1)");
    grad.addColorStop(0.3,"rgba(255,200,120,1)");
    grad.addColorStop(1,"rgba(0,0,0,0)");
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(e.x,e.y,r,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  });
}

// ---- MAIN LOOP ----
function loop(t){
  if(!last) last = t;
  const dt = (t-last)/1000;
  last = t;
  update(dt);
  render();
  requestAnimationFrame(loop);
}
})();
</script>
</body>
</html>
